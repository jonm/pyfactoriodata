#!/usr/bin/env python3

import argparse
import graphlib
import json
import re
import sys
import typing

from pyfactoriodata.fluid import Fluid
from pyfactoriodata.item import Item
from pyfactoriodata.technology import Technology

def parse_args():
    parser = argparse.ArgumentParser(
        prog='generate.py',
        description='generates data-dependent code for python package')
    parser.add_argument('-o','--output-file', dest='output_file',
                        help='write generated python to given file (default: stdout)')
    parser.add_argument('-j','--json-data', dest='json_file',
                        help='specify input json file (default: stdin)')
    args = parser.parse_args()
    return args

def generate_preamble(outf):
    outf.write("""# __init__.py generated by generate.py
import typing

from .fluid import Fluid
from .item import Item
from .technology import Technology
""")
    outf.write('\n')

def generate_item_list(outf, objects, default_stack_size):
    for obj in objects:
        name = obj['name']
        stack_size = obj.get('stack_size', default_stack_size)
        i = Item(name=name, stack_size=stack_size)
        outf.write(f"ITEMS[{name.__repr__()}] = {i.__repr__()}\n")
    
def generate_items(json_data, outf):
    outf.write("""ITEMS : dict[str,Item] = {}\n""")
    for item in json_data['item'].values():
        name = item['name']
        stack_size = item['stack_size']
        outf.write(f"ITEMS[{name.__repr__()}] = Item(name={name.__repr__()},stack_size={stack_size.__repr__()})\n")

    for category in ['armor', 'capsule', 'gun', 'item-with-entity-data',
                     'module', 'spidertron-remote', 'tool']:
        generate_item_list(outf, json_data[category].values(), None)
    generate_item_list(outf, json_data['ammo'].values(), 200)
    generate_item_list(
        outf,
        # filter out crude oil, since it is a fluid and doesn't stack
        filter(lambda o: o.get('category') != 'basic-fluid',
               json_data['resource'].values()),
        50)
    
    # the following items are not under the 'item' heading in the JSON, and
    # do not have stack size data; these are recorded from the Factorio
    # wiki
    EXTRA_ITEMS : dict[int,list[str]] = {
        100 : ['rail']
    }
    for stack_size, names in EXTRA_ITEMS.items():
        for name in names:
            i = Item(name=name, stack_size=stack_size)
            outf.write(f"ITEMS[{name.__repr__()}] = {i.__repr__()}\n")

def generate_item_aliases(outf):
    """These are alternative names for various items, as used by
    the community in various forums/media."""
    ALIASES : dict[str,str] = {
        'active-provider-chest' : 'logistic-chest-active-provider',
        'am1' : 'assembling-machine-1',
        'am2' : 'assembling-machine-2',
        'am3' : 'assembling-machine-3',
        'black-science' : 'military-science-pack',
        'blue-belt' : 'express-transport-belt',
        'blue-chip' : 'processing-unit',
        'blue-inserter' : 'fast-inserter',
        'blue-science' : 'chemical-science-pack',
        'blue-splitter' : 'express-splitter',
        'blue-underground' : 'express-underground-belt',
        'buffer-chest' : 'logistic-chest-buffer',
        'chain-signal' : 'rail-chain-signal',
        'chem-plant' : 'chemical-plant',
        'dull-rock' : 'uranium-238',
        'efficiency-module' : 'effectivity-module',
        'efficiency-module-2' : 'effectivity-module-2',
        'efficiency-module-3' : 'effectivity-module-3',
        'electric-engine' : 'electric-engine-unit',
        'engine' : 'engine-unit',
        'gear' : 'iron-gear-wheel',
        'green-ammo' : 'uranium-rounds-magazine',
        'green-chip' : 'electronic-circuit',
        'green-science' : 'logistic-science-pack',
        'lds' : 'low-density-structure',
        'light' : 'small-lamp',
        'passive-provider-chest' : 'logistic-chest-passive-provider',
        'plastic' : 'plastic-bar',
        'power-pole' : 'small-electric-pole',
        'purple-science' : 'production-science-pack',
        'refinery' : 'oil-refinery',
        'rcu' : 'rocket-control-unit',
        'red-ammo' : 'piercing-rounds-magazine',
        'red-belt' : 'fast-transport-belt',
        'red-chip' : 'advanced-circuit',
        'red-inserter' : 'long-handed-inserter',
        'red-science' : 'automation-science-pack',
        'red-splitter' : 'fast-splitter',
        'red-underground' : 'fast-underground-belt',
        'requester-chest' : 'logistic-chest-requester',
        'robot-frame' : 'flying-robot-frame',
        'shiny-rock' : 'uranium-235',
        'station' : 'train-stop',
        'storage-chest' : 'logistic-chest-storage',
        'turret' : 'gun-turret',
        'underground-pipe' : 'pipe-to-ground',
        'white-science' : 'space-science-pack',
        'yellow-ammo' : 'firearm-magazine',
        'yellow-belt' : 'transport-belt',
        'yellow-inserter' : 'inserter',
        'yellow-science' : 'utility-science-pack',
        'yellow-underground' : 'underground-belt',
    }
    outf.write("""\n# aliases\n""")
    for alias, name in ALIASES.items():
        outf.write(f"""ITEMS[{alias.__repr__()}] = ITEMS[{name.__repr__()}]\n""")

def generate_fluid(outf, obj):
    m = re.match(r"([0-9.]+)KJ", obj.get('heat_capacity',""))
    f = Fluid(
        name = obj['name'],
        default_temperature = obj['default_temperature'],
        heat_capacity_kJ = float(m[1]) if m else None,
        max_temperature = obj.get('max_temperature'),
        gas_temperature = obj.get('gas_temperature'))
    outf.write(f"FLUIDS[{f.name.__repr__()}] = {f.__repr__()}\n")
        
def generate_fluids(json_data, outf):
    outf.write("""
# fluids
FLUIDS : dict[str,Fluid] = {}
""")
    for obj in json_data['fluid'].values():
        generate_fluid(outf, obj)

def generate_technologies(json_data, outf):
    outf.write("""
# technologies
TECHNOLOGIES : dict[str,Technology] = {}
""")
    # topological sort on prereqs; represent the graph as prereqs
    # pointing to the techs they enable, so the prereqs sort "before"
    # them in the resulting order. We want to do this so that we can
    # keep singleton Technology instances in the generated TECHNOLOGIES
    # dict, with later techs pointing to their already-generated
    # prerequisites.
    graph = {}
    for k,v in json_data['technology'].items():
        for prereq in v.get('prerequisites',[]):
            if k not in graph: graph[k] = set()
            graph[k].add(prereq)
            
    for name in tuple(graphlib.TopologicalSorter(graph).static_order()):
        obj = json_data['technology'][name]
        cost_count = obj['unit'].get('count')
        cycle_time_secs = obj['unit']['time']
        outf.write(f"TECHNOLOGIES[{name.__repr__()}] = Technology(name={name.__repr__()},cost_count={cost_count.__repr__()},cycle_time_secs={cycle_time_secs.__repr__()},")
        outf.write("ingredients={")
        outf.write(", ".join([
            f"ITEMS[{i.__repr__()}] : {n}" for i,n in obj['unit']['ingredients']]))
        outf.write("},prerequisites=[")
        outf.write(", ".join([
            f"TECHNOLOGIES[{p.__repr__()}]" for p in obj.get('prerequisites',[])]))
        outf.write("])\n")
        
def generate(json_data, outf):
    generate_preamble(outf)
    generate_items(json_data, outf)
    generate_item_aliases(outf)
    generate_fluids(json_data, outf)
    generate_technologies(json_data, outf)

def main():
    args = parse_args()

    if args.json_file is not None:
        with open(args.json_file,'r') as f:
            json_data = json.load(f)
    else:
        json_data = json.load(sys.stdin)
    
    if args.output_file is not None:
        with open(args.output_file,'w') as outf:
            generate(json_data, outf)
    else:
        generate(json_data, sys.stdout)

if __name__ == "__main__":
    main()
